OUTBASE ?= .
CONFIG_DIR := $(CONFIG)
OUTDIR := $(OUTBASE)/out/$(CONFIG_DIR)
STAMPDIR ?= $(OUTDIR)

EM_CC = emcc
EM_CXX = emcc
EM_CFLAGS = -Wall -s WASM=1


# Convert a source path to a object file path.
# If source path is absolute then just use the basename of for the object
# file name (absolute sources paths with the same basename are not allowed).
# For relative paths use the full path to the source in the object file path
# name.
#
# $1 = Source Name
# $2 = Arch suffix
#
define SRC_TO_OBJ
$(if $(filter /%,$(1)), $(OUTDIR)/$(basename $(notdir $(1)))$(2).bc, $(OUTDIR)/$(basename $(subst ..,__,$(1)))$(2).bc)
endef


#
# Convert a source path to a dependency file path.
# We use the .deps extension for dependencies.  These files are generated by
# fix_deps.py based on the .d files which gcc generates.  We don't reference
# the .d files directly so that we can avoid the the case where the compile
# failed but still generated a .d file (in that case the .d file would not
# be processed by fix_deps.py)
#
# $1 = Source Name
# $2 = Arch suffix
#
define SRC_TO_DEP
$(patsubst %.bc,%.deps,$(call SRC_TO_OBJ,$(1),$(2)))
endef


#
# The gcc-generated deps files end in .d
#
define SRC_TO_DEP_PRE_FIXUP
$(patsubst %.bc,%.d,$(call SRC_TO_OBJ,$(1),$(2)))
endef


#
# Compile Macro
#
# $1 = Source name
# $2 = Compile flags
# $3 = Include directories
#
define C_COMPILER_RULE
-include $(call SRC_TO_DEP,$(1))
$(call SRC_TO_OBJ,$(1)): $(1) $(TOP_MAKE) | $(dir $(call SRC_TO_OBJ,$(1)))dir.stamp
	$(EM_CC) -o $$@ -c $$< $(POSIX_CFLAGS) $(EM_CFLAGS) $(CFLAGS) $(2)
endef

define CXX_COMPILER_RULE
-include $(call SRC_TO_DEP,$(1))
$(call SRC_TO_OBJ,$(1)): $(1) $(TOP_MAKE) | $(dir $(call SRC_TO_OBJ,$(1)))dir.stamp
	$(EM_CXX) -o $$@ -c $$< $(POSIX_CFLAGS) $(EM_CFLAGS) $(CXXFLAGS) $(2)
endef


# $1 = Source Name
# $2 = POSIX Compile Flags
# $3 = Include Directories
# $4 = VC Flags (unused)
define COMPILE_RULE
ifeq ($(suffix $(1)),.c)
$(call C_COMPILER_RULE,$(1),$(2) $(foreach inc,$(INC_PATHS),-I$(inc)) $(3))
else
$(call CXX_COMPILER_RULE,$(1),$(2) $(foreach inc,$(INC_PATHS),-I$(inc)) $(3))
endif
endef


# $1 = Target Name
# $2 = Sources
# $3 = Libs
# $4 = Deps
define LINK_RULE
$(OUTDIR)/$(1).js: $(foreach src,$(SOURCES),$(call SRC_TO_OBJ,$(src)))
	$(EM_CC) -o $$@ $(POSIX_CFLAGS) $(EM_CFLAGS) $(CFLAGS) $$^
endef



#
# Rules for output directories.
#
# Output will be places in a directory name based on Toolchain and configuration
# be default this will be "newlib/Debug".  We use a python wrapped MKDIR to
# proivde a cross platform solution. The use of '|' checks for existance instead
# of timestamp, since the directory can update when files change.
#
%dir.stamp :
	mkdir -p $(dir $@)
	@echo Directory Stamp > $@


#
# Dependency Macro
#
# $1 = Name of stamp
# $2 = Directory for the sub-make
# $3 = Extra Settings
#
#define DEPEND_RULE
#ifndef IGNORE_DEPS
#.PHONY: rebuild_$(1)
#
#rebuild_$(1) :| $(STAMPDIR)/dir.stamp
#ifeq (,$(2))
#	+$(MAKE) -C $(NACL_SDK_ROOT)/src/$(1) STAMPDIR=$(abspath $(STAMPDIR)) $(abspath $(STAMPDIR)/$(1).stamp) $(3)
#else
#	+$(MAKE) -C $(2) STAMPDIR=$(abspath $(STAMPDIR)) $(abspath $(STAMPDIR)/$(1).stamp) $(3)
#endif
#
#all: rebuild_$(1)
#$(STAMPDIR)/$(1).stamp: rebuild_$(1)
#
#else
#
#.PHONY: $(STAMPDIR)/$(1).stamp
#$(STAMPDIR)/$(1).stamp:
#	@echo Ignore $(1)
#endif
#endef
